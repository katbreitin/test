#!/usr/bin/env python
"""
Produces a machine setup file from information in a configuration file.

This program requires either Python version 2.6+ or 3.2+, and is importable as
a python module.
"""

from __future__ import print_function, absolute_import, division, unicode_literals

import sys
import os
import getopt
import io

if sys.version_info[0] >= 3:
    import configparser as cp
    from io import StringIO
else:
    import ConfigParser as cp
    from StringIO import StringIO


#------------------------------------------------------------------------------
def mkdir_p(path):
    """Emulates 'mkdir -p' functionality"""
    if not os.path.isdir(path):
        os.makedirs(path)


#------------------------------------------------------------------------------
def parse_via_configparser(cfg, section, entry, boolean=False):
    """Parse a given section & entry via configparser (+ Python-2 kludges)."""
    if not boolean:
        parsed = cfg.get(section, entry)
        if parsed == "____":
            parsed = ''
    else:
        parsed = cfg.getboolean(section, entry)
    return parsed


#------------------------------------------------------------------------------
def main():
    """Driver."""

    machine_setup_fpath_parts = \
             "env_settings/autogenerated_from_cfg/bec-machine_setup".split('/')
    machine_setup_fpath = os.path.join(*machine_setup_fpath_parts)

    msetup_cfg_fpath_parts = \
             "env_settings/user_change_me.cfg".split('/')
    msetup_cfg_fpath = os.path.join(*msetup_cfg_fpath_parts)

    if not os.path.exists(msetup_cfg_fpath):
        print ("ERROR: Environment settings file ("+ \
               os.path.abspath(msetup_cfg_fpath)+ \
               ") does not exist; please create it from an example in "+ \
               "build/env_settings/examples/\n")
        sys.exit(1)

    cfg = cp.RawConfigParser()

    if sys.version_info[0] < 3:
        # Workaround for Python-2 inflexibility:
        with open(msetup_cfg_fpath, "rt") as text_f:
            msetup_cfg_str_l = []
            for line in text_f:
                ls_line = line.lstrip()
                if len(line)-len(ls_line) < 10:
                    lineA = ls_line
                else:
                    lineA = line
                if len(lineA) >= 1:
                    if not (lineA[0] == '#' or lineA[0] == ';'):
                        parts = lineA.split(':')
                        if parts[-1].strip():
                            if len(parts) > 1:
                                rhs = parts[-1].split("#;")[0]
                                lineB = parts[0]+': '+rhs
                            else:
                                lineB = parts[0]
                        else:
                            lineB = lineA.strip()+' ____\n'
                        msetup_cfg_str_l.append(lineB)
            msetup_cfg_flike = StringIO('\n'.join(msetup_cfg_str_l).encode())
            cfg.readfp(msetup_cfg_flike)
    else:
        cfg.read(msetup_cfg_fpath)

    this_section = "Modules To Load"
    precursor_script = parse_via_configparser(cfg, this_section,
                             "Shell script to load BEFORE (un)loading modules")
    purge_modules_first = parse_via_configparser(cfg, this_section,
                                         "Purge any currently-loaded modules?",
                                                 boolean=True)
    try:
        module_commands = parse_via_configparser(cfg, this_section,
                                              "Modules to (un)load (in order)")
    except:
        # Do not use module commands:
        module_commands = ''
        purge_modules_first = ''

    postcursor_script = parse_via_configparser(cfg, this_section,
                              "Shell script to load AFTER (un)loading modules")

    text_to_write = "##!/bin/sh\n"+"#\n"+"# auto-generated from "+ \
                    msetup_cfg_fpath+"\n"
    text_to_write +="""#
# Intended to contain instructions to properly set up the computing environment
# (especially on large managed clusters/supercomputers).  These will be
# executed during code compilation and/or at runtime.
#
# This code has been written using "heirloom" sh-syntax, which should
#  allow the greatest (easily) possible portability among "modern" computing
#  systems.  All modifications to this code should therefore employ only
#  "heirloom" sh-syntax (e.g., *NO* syntax, assumptions, or structures
#  specific to bash, ksh, tcsh, zsh, or any nonstandard "heirloom" sh).\n
"""

    tmp_str = precursor_script.strip()
    if tmp_str:
        text_to_write += \
              "# First, load any precursor script:\n. "+tmp_str+"\n\n"

    if purge_modules_first:
        text_to_write += \
              "# Remove all currently loaded modules:\n"+"module purge\n\n"

    text_to_write += \
          "# Load and/or unload modules:\n"+module_commands.strip()+"\n\n"

    tmp_str = postcursor_script.strip()
    if tmp_str:
        text_to_write += \
              "# Last, load any postcursor script:\n ."+tmp_str+"\n\n"

    mkdir_p(os.path.dirname(machine_setup_fpath))  # Ensure directory exists
    with open(machine_setup_fpath, "wt") as text_f:
        text_f.write(text_to_write)
            
    sys.exit(0)
    

#------------------------------------------------------------------------------
def usage():
    """Displays a usage message."""
    usage_msg = """
usage: produce_msetup.py [-h]

Produces a machine setup file from information in a configuration file.  This
program requires either Python version 2.6+ or 3.2+, and is importable as a
Python module.

optional argument:
  -h, --help   show this help message and exit
"""
    print(usage_msg)


#------------------------------------------------------------------------------
if __name__ == "__main__":
    # Retrieve command-line options/arguments:
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h', ["help"])
    except getopt.GetoptError as err:
        print(err)
        usage()
        sys.exit(1)

    # Default option values:
      # NONE

    # Act according to the options given:
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit(1)
        else:
            assert False, "unhandled option"

    # Act according to the arguments given:
    if (len(args) > 0):
        print("An incorrect number of arguments were provided.")
        usage()
        sys.exit(1)

    # Perform action(s):
    main()
