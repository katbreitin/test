#!/bin/sh

#------------------------------------------------------------------------------
# [admin]
#
# Shell script that provides a necessary wrapper for managed computer systems.
#
# This code has been written using "heirloom" sh-syntax, which should
#  allow the greatest (easily) possible portability among "modern" computing
#  systems.  All modifications to this code should therefore employ only
#  "heirloom" sh-syntax (e.g., *NO* syntax, assumptions, or structures
#  specific to bash, ksh, tcsh, zsh, or any nonstandard "heirloom" sh).
#------------------------------------------------------------------------------

#set -x;  # Uncomment if debugging

# when_error STATUS ERROR_MESSAGE
# ----
# When STATUS is not 0, output ERROR_MESSAGE.
when_error ()
{
  this_status=$1
  if test $this_status -ne 0; then
    echo "admin: ERROR: $2";
    exit $this_status;
  fi
} # when_error

# Distance ourselves (a tiny bit) from any screen/file litter; Determine
# fully-qualified filesystem location(s) where this script was
# executed from (BEG_DIR) and where this script is located (ANCHOR);
# Store this script's name (SCRIPTNAME): 
echo; BEG_DIR=`pwd`; cd `dirname $0`; ANCHOR=`pwd`; cd "$ANCHOR";
SCRIPT_NAME=`basename $0`;

# After autogenerating the needed file, execute any necessary machine setup
#  instructions ((un)loading modules, etc.):
mach_setup_file="env_settings/autogenerated_from_cfg/bec-machine_setup";
./produce_msetup.py;
when_error $? 'did not successfully produce machine setup file, check [Modules To Load] section in env_settings/user_change_me.cfg';
. "$mach_setup_file";
when_error $? "failed to load machine setup file ($mach_setup_file)";

# A Python script takes it from here:
./py_admin.py $@;
when_error $? "administrative operation failed";

echo; echo "$SCRIPT_NAME has now finished.";
echo; exit 0;
